<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Auto-crop on white background</title>
    <style>
      :root {
        --bg: #0b0c0f;
        --panel: #141622;
        --muted: #8b90a6;
        --text: #e8ebf2;
        --accent: #6aa9ff;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        background: var(--bg);
        color: var(--text);
        font: 14px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell,
          "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji",
          "Segoe UI Emoji";
      }
      .wrap {
        max-width: 980px;
        margin: 32px auto;
        padding: 0 16px;
      }
      h1 {
        font-size: 18px;
        margin: 0 0 12px;
      }
      .grid {
        display: grid;
        grid-template-columns: 1.2fr 1fr;
        gap: 16px;
      }
      .card {
        background: var(--panel);
        border: 1px solid #1e2233;
        border-radius: 12px;
        padding: 14px;
      }
      .hint {
        color: var(--muted);
        font-size: 12px;
      }
      .dropzone {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 240px;
        border: 2px dashed #2b314a;
        border-radius: 12px;
        background: #101325;
        text-align: center;
        padding: 12px;
        user-select: none;
      }
      .dropzone.drag {
        border-color: var(--accent);
        background: #0e1a33;
      }
      .controls {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-top: 10px;
      }
      input[type="number"],
      input[type="text"] {
        background: #0f1220;
        color: var(--text);
        border: 1px solid #252a41;
        border-radius: 8px;
        padding: 8px 10px;
        min-width: 0;
      }
      input[type="text"] {
        flex: 1 1 320px;
      }
      button {
        background: #1a2b4d;
        color: var(--text);
        border: 1px solid #2b3e6b;
        border-radius: 8px;
        padding: 8px 12px;
        cursor: pointer;
      }
      button[disabled] {
        opacity: 0.6;
        cursor: not-allowed;
      }
      canvas,
      img {
        max-width: 100%;
        background: #0b0c0f;
        border-radius: 8px;
      }
      .row {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }
      .kv {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 6px 12px;
        font-size: 12px;
        color: #b5bad0;
      }
      .error {
        color: #ff7a7a;
      }
      .ok {
        color: #7af0a8;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <h1>Auto-crop white-background images</h1>
      <div class="grid">
        <div class="card">
          <div id="dropzone" class="dropzone" aria-label="Drop image here">
            <div>
              <div><strong>Drag an image here</strong></div>
              <div class="hint">
                Also supports paste (Ctrl/Cmd+V), URL load, or file picker.
              </div>
            </div>
          </div>

          <div class="controls">
            <input
              id="urlInput"
              type="text"
              placeholder="https://example.com/image.jpg"
              spellcheck="false"
              inputmode="url"
            />
            <button id="loadUrlBtn" type="button">Load URL</button>
            <input id="fileInput" type="file" accept="image/*" />
          </div>

          <div class="controls">
            <label
              >Margin px
              <input
                id="marginInput"
                type="number"
                value="2"
                min="0"
                max="200"
                step="1"
            /></label>
            <label
              >White tolerance
              <input
                id="tolInput"
                type="number"
                value="10"
                min="0"
                max="60"
                step="1"
            /></label>
            <label
              ><input id="previewBox" type="checkbox" checked /> Show pre-crop
              preview</label
            >
          </div>

          <div id="status" class="hint" role="status"></div>
          <div class="kv" id="meta"></div>
        </div>

        <div class="card">
          <div class="row">
            <button id="copyBtn" type="button" disabled>
              Copy cropped to clipboard
            </button>
            <button id="downloadBtn" type="button" disabled>
              Download PNG
            </button>
            <button id="resetBtn" type="button">Reset</button>
          </div>
          <div class="hint" style="margin-top: 8px">Output</div>
          <canvas
            id="outCanvas"
            width="0"
            height="0"
            aria-label="Cropped output"
          ></canvas>
          <div class="hint" style="margin-top: 8px">
            Optional pre-crop preview
          </div>
          <canvas
            id="previewCanvas"
            width="0"
            height="0"
            aria-label="Preview"
          ></canvas>
        </div>
      </div>
    </div>

    <script>
      (() => {
        "use strict";

        class AutoCropper {
          /**
           * Compute tight bounding box of non-white pixels with tolerance.
           * @param {ImageBitmap|HTMLImageElement|HTMLCanvasElement} src
           * @param {number} whiteTol 0..60 roughly; larger = more aggressive cropping on near-white.
           * @returns {{x:number,y:number,w:number,h:number, tainted:boolean}}
           */
          static computeBounds(src, whiteTol = 10) {
            const w = src.width,
              h = src.height;
            const c = document.createElement("canvas");
            c.width = w;
            c.height = h;
            const g = c.getContext("2d", { willReadFrequently: true });
            g.drawImage(src, 0, 0);

            let tainted = false;
            let data;
            try {
              data = g.getImageData(0, 0, w, h).data;
            } catch (e) {
              tainted = true;
              return { x: 0, y: 0, w, h, tainted };
            }

            const isNonWhite = (r, g, b, a) => {
              // Treat fully transparent as background.
              if (a < 10) return false;
              // Distance from white in max-channel metric.
              const dr = 255 - r,
                dg = 255 - g,
                db = 255 - b;
              const dist = Math.max(dr, dg, db);
              return dist > whiteTol;
            };

            let minX = w,
              minY = h,
              maxX = -1,
              maxY = -1;
            // Scan rows. Early break lines that are all white.
            for (let y = 0; y < h; y++) {
              let rowHas = false;
              const rowStart = y * w * 4;
              for (let x = 0; x < w; x++) {
                const i = rowStart + x * 4;
                const r = data[i],
                  g1 = data[i + 1],
                  b = data[i + 2],
                  a = data[i + 3];
                if (isNonWhite(r, g1, b, a)) {
                  rowHas = true;
                  if (x < minX) minX = x;
                  if (x > maxX) maxX = x;
                }
              }
              if (rowHas) {
                if (y < minY) minY = y;
                if (y > maxY) maxY = y;
              }
            }

            if (maxX < 0 || maxY < 0) {
              // All white. Return full image to avoid empty result.
              return { x: 0, y: 0, w, h, tainted: false };
            }

            return {
              x: minX,
              y: minY,
              w: maxX - minX + 1,
              h: maxY - minY + 1,
              tainted: false,
            };
          }

          /**
           * Crop with margin, clamped to image.
           * @param {CanvasImageSource} src
           * @param {{x:number,y:number,w:number,h:number}} box
           * @param {number} margin
           * @returns {HTMLCanvasElement}
           */
          static cropWithMargin(src, box, margin = 5) {
            const clamp = (v, lo, hi) => Math.min(Math.max(v, lo), hi);
            const sw = src.width,
              sh = src.height;
            const x = clamp(box.x - margin, 0, sw - 1);
            const y = clamp(box.y - margin, 0, sh - 1);
            const r = clamp(box.x + box.w + margin, 0, sw);
            const b = clamp(box.y + box.h + margin, 0, sh);
            const w = Math.max(1, r - x);
            const h = Math.max(1, b - y);

            const out = document.createElement("canvas");
            out.width = w;
            out.height = h;
            const g = out.getContext("2d");
            g.drawImage(src, x, y, w, h, 0, 0, w, h);
            return out;
          }
        }

        class App {
          constructor() {
            this.elements = {
              dropzone: document.getElementById("dropzone"),
              urlInput: document.getElementById("urlInput"),
              loadUrlBtn: document.getElementById("loadUrlBtn"),
              fileInput: document.getElementById("fileInput"),
              marginInput: document.getElementById("marginInput"),
              tolInput: document.getElementById("tolInput"),
              previewBox: document.getElementById("previewBox"),
              outCanvas: document.getElementById("outCanvas"),
              previewCanvas: document.getElementById("previewCanvas"),
              copyBtn: document.getElementById("copyBtn"),
              downloadBtn: document.getElementById("downloadBtn"),
              resetBtn: document.getElementById("resetBtn"),
              status: document.getElementById("status"),
              meta: document.getElementById("meta"),
            };

            this.sourceBitmap = null;
            this.lastObjectUrl = null;

            this.bindEvents();
            this.bindGlobalPaste();
            this.loadSettings();
            this.setStatus("Ready. Drag an image or paste.", "ok");
          }

          bindEvents() {
            const dz = this.elements.dropzone;
            ["dragenter", "dragover"].forEach((evt) =>
              dz.addEventListener(evt, (e) => {
                e.preventDefault();
                dz.classList.add("drag");
              })
            );
            ["dragleave", "drop"].forEach((evt) =>
              dz.addEventListener(evt, (e) => {
                e.preventDefault();
                dz.classList.remove("drag");
              })
            );
            dz.addEventListener("drop", (e) => this.handleDrop(e));

            this.elements.fileInput.addEventListener("change", (e) => {
              const f = e.target.files && e.target.files[0];
              if (f) this.loadFromFile(f);
            });
            this.elements.loadUrlBtn.addEventListener("click", () =>
              this.loadFromUrl()
            );
            this.elements.marginInput.addEventListener("change", () => {
              this.saveSettings();
              this.reprocess();
            });
            this.elements.tolInput.addEventListener("change", () => {
              this.saveSettings();
              this.reprocess();
            });
            this.elements.previewBox.addEventListener("change", () => {
              this.saveSettings();
              this.updatePreviewVisibility();
            });

            this.elements.copyBtn.addEventListener("click", () =>
              this.copyOutput()
            );
            this.elements.downloadBtn.addEventListener("click", () =>
              this.downloadOutput()
            );
            this.elements.resetBtn.addEventListener("click", () =>
              this.reset()
            );
          }

          bindGlobalPaste() {
            window.addEventListener("paste", async (e) => {
              const items = Array.from(e.clipboardData?.items || []);
              const imgItem = items.find((i) => i.type.startsWith("image/"));
              if (imgItem) {
                e.preventDefault();
                const blob = imgItem.getAsFile();
                if (blob) {
                  this.setStatus("Pasted image.", "ok");
                  await this.loadFromBlob(blob);
                }
                return;
              }
              const text = e.clipboardData?.getData("text");
              if (text && /^https?:\/\//i.test(text)) {
                e.preventDefault();
                this.elements.urlInput.value = text.trim();
                this.loadFromUrl().catch(() => {});
              }
            });
          }

          // bindGlobalPaste() {
          //   window.addEventListener("paste", async (e) => {
          //     const target = e.target;
          //     const isUrlField = target === this.elements.urlInput;

          //     const items = Array.from(e.clipboardData?.items || []);
          //     const imgItem = items.find((i) => i.type.startsWith("image/"));
          //     if (imgItem) {
          //       e.preventDefault(); // avoid inserting junk into focused inputs
          //       const blob = imgItem.getAsFile();
          //       if (blob) {
          //         this.setStatus("Pasted image.", "ok");
          //         await this.loadFromBlob(blob);
          //       }
          //       return;
          //     }

          //     const text = e.clipboardData?.getData("text");
          //     if (text && /^https?:\/\//i.test(text)) {
          //       if (!isUrlField) {
          //         e.preventDefault(); // we set the value ourselves
          //         this.elements.urlInput.value = text.trim();
          //       }
          //       this.loadFromUrl().catch(() => {});
          //     }
          //   });
          // }

          async handleDrop(e) {
            const dt = e.dataTransfer;
            // Prefer file drops
            if (dt.files && dt.files.length) {
              this.loadFromFile(dt.files[0]);
              return;
            }
            // If dragging from a web page, we often get a URL
            const url = dt.getData("text/uri-list") || dt.getData("text/plain");
            if (url && /^https?:\/\//i.test(url)) {
              this.elements.urlInput.value = url.trim();
              await this.loadFromUrl();
              return;
            }
            this.setStatus(
              "Unsupported drop payload. Drop an image file or a URL.",
              "error"
            );
          }

          async loadFromUrl() {
            const urlRaw = this.elements.urlInput.value.trim();
            if (!/^https?:\/\//i.test(urlRaw)) {
              this.setStatus("Enter a valid http(s) URL.", "error");
              return;
            }
            const url = new URL(urlRaw); // throws if invalid
            // Security: only http/https
            if (!["http:", "https:"].includes(url.protocol)) {
              this.setStatus("Only http(s) URLs are allowed.", "error");
              return;
            }
            this.setStatus("Loading image via CORS…");
            try {
              const img = await this.fetchImageAsBitmap(url.toString());
              await this.setSource(img);
              this.setStatus("Loaded via URL.", "ok");
            } catch (err) {
              this.setStatus(
                "Could not read pixels from this URL. The server likely blocks CORS. Save the image and drop it here, or paste it.",
                "error"
              );
              console.error(err);
            }
          }

          async fetchImageAsBitmap(url) {
            // Try fetch to avoid image decode events and allow same code path for blobs.
            const res = await fetch(url, { mode: "cors", credentials: "omit" });
            if (!res.ok) throw new Error("HTTP " + res.status);
            const blob = await res.blob();
            return createImageBitmap(blob);
          }

          async loadFromFile(file) {
            if (!file.type.startsWith("image/")) {
              this.setStatus("File is not an image.", "error");
              return;
            }
            this.setStatus(`Loading ${file.name}…`);
            await this.loadFromBlob(file);
          }

          async loadFromBlob(blob) {
            // Revoke previous object URL if any
            if (this.lastObjectUrl) URL.revokeObjectURL(this.lastObjectUrl);
            this.lastObjectUrl = URL.createObjectURL(blob);
            try {
              const bmp = await createImageBitmap(blob);
              await this.setSource(bmp);
              this.setStatus("Loaded image from file/paste.", "ok");
            } catch (e) {
              this.setStatus("Failed to decode image.", "error");
              console.error(e);
            }
          }

          async setSource(bitmap) {
            this.sourceBitmap = bitmap;
            this.reprocess();
          }

          reprocess() {
            if (!this.sourceBitmap) return;
            const tol = this.parseBoundedInt(
              this.elements.tolInput.value,
              0,
              60,
              10
            );
            const margin = this.parseBoundedInt(
              this.elements.marginInput.value,
              0,
              200,
              5
            );

            const bounds = AutoCropper.computeBounds(this.sourceBitmap, tol);
            const metaEl = this.elements.meta;
            metaEl.innerHTML = "";
            const addMeta = (k, v) => {
              const kEl = document.createElement("div");
              kEl.textContent = k;
              const vEl = document.createElement("div");
              vEl.textContent = String(v);
              metaEl.appendChild(kEl);
              metaEl.appendChild(vEl);
            };

            addMeta(
              "Source",
              `${this.sourceBitmap.width}×${this.sourceBitmap.height}`
            );
            if (bounds.tainted) {
              addMeta("Tainted", "yes");
              this.setStatus(
                "Canvas is tainted by cross-origin image. Paste or download the image and drop the file.",
                "error"
              );
              this.disableOutput();
              return;
            } else {
              addMeta("Tainted", "no");
            }

            addMeta(
              "BBox",
              `${bounds.x},${bounds.y} → ${bounds.w}×${bounds.h}`
            );
            addMeta("Margin", `${margin}px`);
            const cropped = AutoCropper.cropWithMargin(
              this.sourceBitmap,
              bounds,
              margin
            );

            // Draw output
            this.drawToCanvas(this.elements.outCanvas, cropped);
            this.enableOutput();
            this.updatePreviewVisibility();

            // Optional pre-crop preview with bbox overlay
            const prevCanvas = this.elements.previewCanvas;
            prevCanvas.width = this.sourceBitmap.width;
            prevCanvas.height = this.sourceBitmap.height;
            const pg = prevCanvas.getContext("2d");
            pg.clearRect(0, 0, prevCanvas.width, prevCanvas.height);
            pg.drawImage(this.sourceBitmap, 0, 0);
            pg.strokeStyle = "#6aa9ff";
            pg.lineWidth = 2;
            pg.strokeRect(bounds.x, bounds.y, bounds.w, bounds.h);
          }

          drawToCanvas(canvas, srcCanvas) {
            canvas.width = srcCanvas.width;
            canvas.height = srcCanvas.height;
            const g = canvas.getContext("2d");
            g.clearRect(0, 0, canvas.width, canvas.height);
            g.drawImage(srcCanvas, 0, 0);
          }

          updatePreviewVisibility() {
            const show = this.elements.previewBox.checked;
            this.elements.previewCanvas.style.display = show ? "block" : "none";
          }

          enableOutput() {
            this.elements.copyBtn.disabled = false;
            this.elements.downloadBtn.disabled = false;
          }
          disableOutput() {
            this.elements.copyBtn.disabled = true;
            this.elements.downloadBtn.disabled = true;
          }

          async copyOutput() {
            const c = this.elements.outCanvas;
            try {
              const blob = await new Promise((res) =>
                c.toBlob(res, "image/png")
              );
              if (!blob) throw new Error("toBlob failed");
              await navigator.clipboard.write([
                new ClipboardItem({ [blob.type]: blob }),
              ]);
              this.setStatus("Copied output PNG to clipboard.", "ok");
            } catch (e) {
              this.setStatus(
                "Clipboard copy failed. Your browser may block it in file://. Download instead.",
                "error"
              );
              console.error(e);
            }
          }

          downloadOutput() {
            const c = this.elements.outCanvas;
            c.toBlob((blob) => {
              if (!blob) return;
              const url = URL.createObjectURL(blob);
              const a = document.createElement("a");
              a.href = url;
              a.download = "cropped.png";
              document.body.appendChild(a);
              a.click();
              a.remove();
              setTimeout(() => URL.revokeObjectURL(url), 0);
            }, "image/png");
          }

          reset() {
            this.sourceBitmap = null;
            this.elements.outCanvas.width = 0;
            this.elements.outCanvas.height = 0;
            this.elements.previewCanvas.width = 0;
            this.elements.previewCanvas.height = 0;
            this.elements.meta.innerHTML = "";
            this.disableOutput();
            this.setStatus("Reset.", "ok");
          }

          setStatus(text, kind = "hint") {
            const el = this.elements.status;
            el.textContent = text;
            el.className =
              kind === "error" ? "error" : kind === "ok" ? "ok" : "hint";
          }

          parseBoundedInt(v, min, max, fallback) {
            let n = Number.parseInt(v, 10);
            if (!Number.isFinite(n)) n = fallback;
            return Math.min(Math.max(n, min), max);
          }

          loadSettings() {
            try {
              const s = JSON.parse(
                localStorage.getItem("autocrop-settings") || "{}"
              );
              if (s.margin != null) this.elements.marginInput.value = s.margin;
              if (s.tol != null) this.elements.tolInput.value = s.tol;
              if (s.preview != null)
                this.elements.previewBox.checked = s.preview;
            } catch {}
          }

          saveSettings() {
            const s = {
              margin: this.elements.marginInput.value,
              tol: this.elements.tolInput.value,
              preview: this.elements.previewBox.checked,
            };
            localStorage.setItem("autocrop-settings", JSON.stringify(s));
          }
        }

        // Instantiate app
        new App();
      })();
    </script>
  </body>
</html>
